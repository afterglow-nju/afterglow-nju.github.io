## 第一讲 操作系统概述 

why what how😱:scream_cat:



---



## 第二讲 操作系统上的程序

### 程序状态机的模型

- 状态=寄存器的值 

  regs_foreach gcc -E a.c

### 源代码视角什么是程序

c程序的状态机模型：堆，栈

可以用gdb执行每一步，观察堆栈发生变化 layout src进入源代码模式

### 二进制视角什么是程序

同样gdb看一条条汇编(layout asm)

wa 加watch point

如果程序只计算的话就不会退出，所以需要syscall，把当前运行程序的所有状态交给操作系统，由操作系统决定返回的状态。实现了操作系统与其他对象的交互，包括读写文件，创建进程，退出进程

所以现在状态机的视角除了计算，还有syscall

最小hello,world的实现 

程序视角的操作系统就是syscall

escape code

### 如何在程序的两个视角之间切换

现在有两种状态机，c语言和汇编，如何在程序的两个视角之间切换？

c=compile(s) 通过编译器

什么叫**正确编译**？

c代码定义一个状态机，汇编也定义了一个状态机，正确编译：所有c代码上不可优化(volatile, syacall...)的部分都在汇编的状态机上实现

strace

strace -f gcc a.c可以查看编译器干了什么

strace xedit图形化界面

用gdb, strace查看状态机任意状态

<img src="D:\typora_picture\image-20220216155807771.png" alt="image-20220216155807771" style="zoom: 33%;" />



---



## 第三讲 多处理器编程 

### Overview

- c语言状态机，每一步是一条语句(单线程)
- 本节课内容：多处理器时代，如何理解？如果单线程到多线程(并发程序的状态机)

### 并发(Concurrent)

<img src="D:\typora_picture\image-20220221101554014.png" alt="image-20220221101554014" style="zoom:50%;" />

系统调用代码是最早的并发程序

### 并发的基本单位：线程

多个执行流，拥有独立的栈帧，共享内存等资源

全部变量和堆区共享，栈帧(栈帧里有pc和局部变量)独立

有一个选择器每次选择不同的线程执行

并发程序执行的每一步都是不确定的

### 入门：thread.h简化的线程API

`create`创建一个线程

- 语义：在状态中新增 stack frame 列表并初始化为 `fn(tid)`

`join`等待所有运行线程的 `fn` 返回

- 语义：在有其他线程未执行完时死循环，否则返回

gcc a.c -lpthread && ./a.out

top显示cpu等使用率

如何证明线程确实共享内存？ shm-test.c 全部变量各个线程都可以访问到

如何证明线程具有独立的堆栈？stack-probe.c ,sort -nk

创建线程使用的是clone系统调用

### 原子性

>  **原子性的丧失**：“程序 (甚至是一条指令) 独占处理器执行” 的基本假设在现代多处理器系统上不再成立。

printf还能用吗？ man 3 printf $\to$ thread safety

实现原子性

- lock
- unlock

### 顺序

代码和汇编代码的顺序不一样

编译器对内存访问的优化，而并发程序又是共享内存的，所以会出现问题 

不同优化导致sum输出不同

> 编译器对内存访问 “eventually consistent” 的处理导致共享内存作为线程同步工具的失效。

- `-O1`: `R[eax] = sum; R[eax] += N; sum = R[eax]`
- `-O2`: `sum += N;`

### 可见性

mem-ordering.c

sort | uniq -c

处理器把汇编代码 (用电路) “编译” 成更小的 $\mu ops$

处理器维护一个$\mu op$ 池子，里面有指令之间的依赖关系和顺序关系，是一个DAG，所以会改变汇编指令执行的顺序，而这个改变是我们所看不到的

> 多处理器间即时可见性的丧失

如何实现顺序一致性

- `mfence`
- 原子指令

### Take-away message

- 多处理器编程：入门
  - 多处理器程序 = 状态机 (共享内存；非确定选择线程执行)
  - thread.h = create + join
- 多处理器编程：**放弃你对 “程序” 的旧理解**(sequential being)
  - 不原子、能乱序、不立即可见
    - 来自于编译优化 (处理器也是编译器)



---



## 第四讲 理解并发程序执行 :1st_place_medal:(画状态机)

### Overview

- 并发程序=多个执行流、共享内存的状态机

- 本次课回答的问题

  - **Q**: 如何阅读理解教科书/互联网/期末试卷上的各种并发程序？

- 本次课主要内容：(自动) 画状态机理解并发程序

### 共享内存上的互斥 

> 互斥：保证两个线程不能同时执行一段代码

最简单的实现(if判断)不可行，因为load(判断是否锁上)和store(如果没锁就锁上)之间的原子性不能保证

#### Peterson算法(并发协议)

store(x):改状态，举旗子贴牌子

load(x):看状态

与山寨支付宝不同

- 谁手快谁进

并发算法的设计困境：不敢不画，不敢乱画，但画好累

能不能让电脑帮我们画？

### Model Checker

python3 model-checker.py mutex-bad.py | python3 visualize.py > a.html

代码导读

g

在python里创建状态机

在每一个线程函数中，在每一条语句前在yield

只要为系统建立模型，就能用穷举法证明

本次课回答的问题

- **Q**: 如何理解各种并发程序？

------

Take-away message

- 并发程序 = 状态机
  - 线程共享内存
  - 每一步非确定选择线程执行
- 画状态机就对了
  - 当然，用工具帮你画 (**model checker**)

我人傻了，太强了:crying_cat_face:



---



## 第五讲 并发控制：互斥

在多处理线程上实现互斥

- 物理空间是并行的，而线程，完成局部存储和计算是独立的
- 实现互斥的根本困难是因为只用load和store不能同时读写，解决方案：依靠硬件实现一条原子化的指令，同时读写？

### 自旋锁

基本原理:钥匙和别的东西交换

##### xchg原子化的交换指令实现互斥

x86的lock

```c
asm volatile ("lock xchg %0, %1"
    : "+m"(*addr), "=a"(result) : "1"(newval));
//xchg是两条指令综合，交换两个数值，其实xchg本身自带原子性，lock去掉也可
```

锁和其他值交换，交换到🔒才可以进

```c
int locked = 0;//0是可以进
void lock() { while (xchg(&locked, 1)) ; }
void unlock() { xchg(&locked, 0); }
```

并发编程尽量多做测试，model checker

处理器保证多线程时，lock指令会有一个完全的顺序，不是并行，这是原子性的保证

- 在486上，单纯是在主存上加一把锁，但是现代计算机中(x86)，每个cpu都有属于自己的缓存，只在主存上加一把锁不够，还要保证cache的一致性
- risc-v用了比较巧的方法，`Load-Reserved/Store-Conditional`实现读写的原子性

缺陷：只有一个线程进入临界区，其他线程都在空转.尤其当只有一个cpu时，利用率更低，更有甚者，如果获得自旋锁的线程被切换出去，100%资源浪费
sum-scalability.c同一个任务量，线程数越多，效率越低

自旋锁使用场景：

- 锁发生争抢的情况很少
- 持有自旋锁时禁止执行流切换，但是应用程序做不到
  - 所以真正的使用场景是操作系统内核

### Futex

自旋锁与睡眠:lock:(系统调用))各有利弊

全都要：

- fast path一条原子指令上锁
- slow path上锁失败，执行系统调用睡眠

线程库里的互斥锁mutex



---



## 第六讲 并发控制：同步

本次课的任务：如何写并发程序

线程同步：在某一个时间点，达到互相已知的状态

### 条件变量

- 保证线程发生的顺序

- `wait()`会干两件事：释放锁并让调用线程休眠
  当线程被唤醒后，它将重新获取锁，再返回调用者

- **调用`signal`和`wait`时都要持有锁**
  `Pthread_cond_wait(&cond,&mutex)`
  `Pthread_cond_signal(&cond)`

  ---

### 生产者消费者

- **对条件变量使用while**

  - 发信号给线程只是唤醒他们，暗示状态发生变化，但不保证在该线程运算之前的状态一直是期望的情况，即中间可能有别的线程又改变了状况---mesa语义

- 使用两个条件变量以便正确的发出信号，唤醒期望的线程

  - ```c
    Pthread_cond_wait(&empty,&mutex)
    Pthread_cond_signal(&fill)
    ```

- 或者使用覆盖条件，用`Pthread_cond_broadcast替换Pthread_cond_signal`，覆盖所有需要唤醒线程的场景



嵌套深度不太深时可以打左括号，能配对时打右括号

可以写一个程序进行压力测试

条件变量的设置，在什么情况可以打，把状态机转移的情况都列出来

死锁

### 避免不成熟的优化(Knuth 定理)

实现并发数据结构时，先从最简单方案开始，加一大把:lock:来同步，如果遇到性能问题，再改进



---



## 第七讲 真实世界的并发编程

### 如何在超算上编程

- 分解计算任务
- 线程之间通信

线程优点就是可以用多处理器，并行执行，问题就是线程之间转换需要一定的时间

协程不受操作系统调用，如果是一个线程多个协程，一个协程block，整个线程就block

`Go`：系统编程，多处理器并行和轻量化并发都可

旋转进度条



---



## 第八讲 并发bug和应对 

> 软件是现实世界的需求 (规约) 在计算机数学世界的投影

### 防御性编程

关于需求的更多信息被计算机忽略了，解决方法之一就是多加断言，把程序需要满足的条件用`assert`表示出来

`type annotation: CHECK_INT CHECK_HEAP`

### 并发bug：死锁(Deadlock)

线程互相等待

避免死锁

### 并发bug：数据竞争(Data Race)

> 不同线程同时访问同一段内存，至少一个是写

### 更多类型的bug

原子性违反，顺序违反

### 应对并发bug的方法

- 静态分析 -Wall -Werror
- 动态分析 用些小工具，打印日志...
- sanitizer小工具在实验中应该挺有用的
- L1 防止double allocation 赋不同的值

---



## 第九讲 操作系统状态机模型

starti layout asm

### Bare-mental 与程序员约定

为了让计算机能运行任何程序，一定**存在软件与硬件的约定**

软件和硬件之间约定，在cpu reset后pc指向一个有效的指令，接着周而复始的执行，将软件和硬件联系起来

reset后直接执行的代码不是操作系统，而是硬件厂商提供的代码(firmware固件)

BIOS扫描每个硬盘的前512个字节(MBR 主引导扇区)，如果可行(?)，就将其加载入内存，随后进入操作系统

mpe-init 把单线程的c程序变成多线程的c程序

vscode正确跳转，把编译选项(带宏的，-I -D)设置

set nowrap



---

## 第十讲 状态机模型的应用

mpe-init随后便有多个mpe-entry

#### 状态机：理解物理世界

细胞自动机

宏观物理世界近似于deterministic 
微观世界可能是 non-deterministic

#### 状态机：理解编译器和现代CPU

现在可以在一个时间周期中同时执行多条语句

`ilp-demo.c`

#### Trace和调试器

gdb停在某一个状态上，记录和**改变**一个状态

<img src="D:\typora_picture\image-20220316143823522.png" alt="image-20220316143823522" style="zoom: 33%;" />

时间回溯

- 记录每一条指令的“负作用”，回溯就是恢复这条指令带来的影响
- `record full开始记录` `rsi(reverse-stepi)回溯` `recoed stop结束记录`
- 但syscall可能不太行

#### profiler

隔一段时间暂停程序，观察状态机的执行

model-checker sum.c试一下为什么不对

---

## 第十一讲 操作系统的进程

### 从系统启动到第一个进程

- CPU Reset → Firmware → Boot loader → Kernel `_start()`→ 第一个程序 `/bin/init` → 程序 (状态机) 执行 + 系统调用

操作系统会加载第一个程序，随后将控制权交给这个程序，可以从pstree验证这个想法，第一个程序就是树根(systemd)

创建最小的linux的内核

init，创建进程+系统调用(进程、内存、文件)

#### fork()

进入操作系统内核，创建一个完全一样的状态机
两个完全一样(内存每个字节，寄存器，pc)的状态机副本，除了fork的返回值
执行fork的进程返回的是被创建进程的进程号，被创建的进程fork返回值是0

现在有两个进程了

fork在复制时库函数内部状态也复制了两份

```c
stdout:tty line buffer 遇到\n将缓冲区内容输出
pipe/file  full buffer 等到满足某个字节后一起输出
```

#### execve()

< if(pid==0) > 重置一个状态机，重置为某一个程序的初始状态

环境变量就是重置状态机的参数,是应用程序执行的环境

#### _exit()

exit 的几种写法 (它们是不同)

- `exit(0)` - `stdlib.h` 中声明的 libc 函数
  - 会调用 `atexit`
- `_exit(0)` - glibc 的 syscall wrapper
  - 执行 “`exit_group`” 系统调用终止整个进程 (所有线程)
  - 不会调用`atexit`
- `syscall(SYS_exit,0)`
  - 执行`exit`系统调用终止当前进程
  - 不会调用`atexit`

---

## 第十二讲 进程的地址空间

#### 查看进程的地址空间

- 通过gdb`info inferiors`查看进程号
- `pmap pid(进程号)`report memory of a process `man 5 proc`

`vdso (7): Virtual system calls:` 只读的系统调用也许可以不陷入内核执行
不进入操作系统内核完成系统调用，即非陷入系统调用

#### 管理进程的地址空间

- `mmap(syscall)`：

  ```c++
  // 映射
  void *mmap(void *addr, size_t length, int prot, int flags,
             int fd, off_t offset);
  //prot权限，flags映射的方式，fd,offset文件的描述
  int munmap(void *addr, size_t length);
  
  // 修改映射权限
  int mprotect(void *addr, size_t length, int prot);
  ```

#### 地址空间的隔离

---

## 期中复习

- <img src="D:\typora_picture\image-20220328084544295.png" alt="image-20220328084544295" style="zoom: 50%;" />

- 自旋锁：就是交换/xchg
  只有一个线程执行，其余线程空转，即while(1)死循环
  使用场景是系统内核
- 互斥锁
- `fast path`：进入临界区
  `slow path`:🔒被别的线程占用
- `Futex`
  `fast path`一条原子指令
  `slow path`上锁失败，执行系统调用睡眠

---

## 第十三讲 系统调用和UNIX Shell

UNIX Shell设计和实现

操作系统是状态机，可以管理很多的程序

#### Shell介绍

操作系统内核(kernel)，关于syscall实现

shell是操作系统内核外面的一层壳，帮助用户和操作系统交互

> Shell 是一门 “把用户指令翻译成系统调用” 的编程语言

#### 复刻Shell

[sh-xv6.c](http://jyywiki.cn/pages/OS/2022/demos/sh-xv6.c)

- 无库函数依赖

- 编译以后可以直接运行，就像shell一样

- 执行命令就是Execve的系统调用

- 把命令翻译成一棵树，再执行系统调用

- `pipe`

  ```shell
  strace -f -o strace.log ./sh
  ```

  这样可以实时观看sh系统调用

#### 终端

为什么crtl+c能退出？发送一个SIGINT信号

 [signal-handler.c](http://jyywiki.cn/pages/OS/2022/demos/signal-handler.c).

进程组，分前台和后台进程组，实现job control

---

## 第十四讲 C标准库的实现

### libc的重要性

满足程序在不同机器上的可移植性

高情商 API：

```c
execlp("echo", "echo", "hello", "world", NULL);
system("echo hello world");
```

标准库函数要考虑的更多，多线程？不同的CPU...

### 封装文件描述符

---

## 第十五讲 A fork() in the Road

### fork() 行为的补充解释

execve重置状态机，但是操作系统的对象仍然不变，比如文件描述符，父进程和子进程都指向同一个终端

文件描述符

- 是一个指向操作系统内部对象的“指针”
- 从 0 开始编号 (0, 1, 2 分别是 stdin, stdout, stderr)
- 可以通过 open 取得；close 释放；dup “复制”
- 对于数据文件，文件描述符会 “记住” 上次访问文件的位置，即文件偏移量
  - `write(3, "a", 1); write(3, "b", 1);` 结果应该是`ab`
  - fork后仍然保证不覆盖
  - dup()的两个文件描述符是共享offset

fork创建两个副本，代价很大

- **`copy-on write`**

  - 进程并不拥有页面，页面都是操作系统持有的，进程有的只是映射表. 当fork后让子进程共享父进程的页面，如果页面的权限是只读，那没事；如果页面的权限是读写，操作系统先“抹掉”写权限，如果进程要写，即访问这个页面，则缺页中断(page fault)，复制一份给要调用的进程。

  - 概念上状态机被复制，但实际上复制后内存都被共享
    - “Copy-on-write” 只有被写入的页面才会复制一份
      - 被复制后，整个地址空间都被标记为 “只读”
      - 操作系统捕获 Page Fault 后酌情复制页面
      - fork-execve 效率得到提升
    - 操作系统会维护每个页面的引用计数

- 推论：统计进程占用的内存是个伪命题

### 状态机的魔法 :timer_clock: :fire:

### 搜索并行化--创建平行宇宙

用dfs走迷宫，不用回溯，直接fork遍历各个情况，不用再恢复情况了

- 跳过初始化，初始化后想用就fork，共享
- 备份和容错 



---

## 第十六讲 可执行文件、链接和加载

本堂课内容关于 可执行文件如何在操作系统上被执行的

### 可执行文件

可执行文件：是一个数据结构，描述了状态机的初始状态

- 寄存器
  - 大部分由 ABI 规定，操作系统负责设置
  - 例如初始的 PC
- 地址空间
  - 二进制文件 + ABI 共同决定
  - 例如 argv 和 envp (和其他信息) 的存储

需要满足若干条件

- 具有可执行的(x)权限
- 加载器能识别的可执行文件

是execve决定了一个文件是否能执行, execve(xxx,....)=-1执行失败

execve(2)的手册中ERRORS规定了什么时候不能执行

常见的可执行文件

UNIX/Linux

- a.out (deprecated)
- ELF (Executable Linkable Format)
- **She-bang**
  - 我们可以试着 She-bang 一个自己的可执行文件！
  - She-bang 其实是一个 “偷换参数” 的 execve
    - #!xxxx，将xxxx作为execve的第一个参数

### 解析可执行文件

#### Binutils - Binary Utilities

[GNU binutils](https://www.gnu.org/software/binutils/) 一些解析二进制描述的数据结构的小工具

- 生成可执行文件
  - ld (linker), as (assembler)
  - ar, ranlib
- 分析可执行文件
  - objcopy/objdump/readelf (计算机系统基础)
  - addr2line, size, nm

#### 调试信息

编译器在编译时会额外生成一些信息来debug用

### 编译连接

编译器生成文本汇编代码$\to$汇编器生成二进制指令序列

编译器 (gcc)

- High-level semantics (C 状态机) → low-level semantics (汇编)

汇编器 (as)

- Low-level semantics → Binary semantics (状态机容器)
  - “一一对应” 地翻译成二进制代码
    - sections, symbols, debug info
  - 不能决定的要留下 “之后怎么办” 的信息
    - relocations(重填，S+A-P)

所以ELF 就是一个 “容器数据结构”，包含了必要的信息

---



## 第十七讲 可执行文件的加载

### 静态ELF加载器

可执行文件

- 一个描述了状态机的初始状态 (迁移) 的**数据结构**
  - 不同于内存里的数据结构，“指针” 都被 “偏移量” 代替

加载器(**loader**)

- 解析数据结构 + 复制到内存 + 跳转

- loader除了将elf中文件搬到内存指定位置，还有一些运行时状态(argv,envp)也会被传递
- 栈上的一些参数也准备好了
- 用open,mmap,close实现了一个execve

加载操作系统内核和这很相似，用的是Boot Block Loader

### 动态链接和加载

运行时链接，省空间；而且当库更新时，不需要重新编译整个文件

先找一块数据填成0，间接跳转，加载器加载时再将这一部分添上正确的地址

:warning: :warning::warning::warning::warning::warning::warning::warning::warning::warning:再看一下视频











---

## :book: 第15章 地址转换机制 :blue_book:

在实现虚拟内存时，我们追求的是高效和控制

高效意味着要利用硬件的支持，控制意味着操作系统要确保程序只能访问自己的内存空间

解决从虚拟地址到物理地址重定向问题的一种通用技术称为：基于硬件的**地址转换**

### 基址加界限基址，动态重定位

思想：CPU有两个硬件寄存器：基址寄存器(base)和界限寄存器(bound)

进程的内存引用会被这样的转换成物理地址  `physical address=virtual address +base`

即虚拟地址加上基址寄存器中的内容得到物理地址，其中界限寄存器中既可以存放结束的物理地址，也可以存放地址空间的大小

操作系统除了提供
